package T494;

/*给你一个非负整数数组 nums 和一个整数 target 。
向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ：
例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1" 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。
示例 1：
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
示例 2：
输入：nums = [1], target = 1
输出：1 */
//其实也不必担心这种背包问题不是最优解
//你看他的解题过程，他是每种背包容量要不要放每种物品都做了一次判断的，fori又forj的嘛。
//再就是别忘了背包问题是动态规划的一种，它是有递推公式的
class Solution {
  public int findTargetSumWays(int[] nums, int target) {
    //我看这背包问题就是个凑数问题，尽量往上凑，不能超过上限，等于上限是最好的
    //这个题的题解就是得等于上限
  }
}